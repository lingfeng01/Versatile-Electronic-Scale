C51 COMPILER V9.59.0.0   APP_MAIN                                                          12/25/2024 14:50:49 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE APP_MAIN
OBJECT MODULE PLACED IN .\Objects\app_main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE App\app_main.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\App;.\divers
                    -;.\main) DEBUG PRINT(.\Listings\app_main.lst) TABS(2) OBJECT(.\Objects\app_main.obj)

line level    source

   1          #include "app_main.h"
   2          
   3          char *USER_DEVICEDESC = NULL;
   4          char *USER_PRODUCTDESC = NULL;
   5          char *USER_STCISPCMD = "@STCISP#"; // å¯ä»¥è‡ªå®šä¹‰
   6          char LCDstr[15];
   7          BYTE usbStr[64];
   8          
   9          int chishu = 0;
  10          uint weight = 0;                 // æ˜¾ç¤ºé‡é‡
  11          uint threshold = 0;              // é˜ˆå€¼
  12          uint weight_k = 400;             // é‡é‡ç³»æ•°
  13          uint weight_k2 = 0;              // é‡é‡ç³»æ•°
  14          uint usb_weight_k = 400;         // USBé‡é‡ç³»æ•°
  15          uchar EEPROM_weight_k[16] = {0}; // EEPROMé‡é‡ç³»æ•°
  16          uint weight_tare = 0;            // çš®é‡é‡
  17          uint weight_tare_after = 0;      // å»çš®åé‡é‡
  18          uint weight_count = 100;         // è®¡æ•°é‡é‡
  19          ulong weight_base = 0;           // åŸºå‡†é‡é‡
  20          ulong poll_neg_t = 0;            // é‡é‡è´Ÿå€¼æ—¶é—´
  21          ulong weigh_poll_neg_t = 0;      // é‡é‡è´Ÿå€¼æ—¶é—´
  22          ulong beep_neg_time = 0;         // èœ‚é¸£å™¨è´Ÿå€¼æ—¶é—´
  23          uint beep_poll_time = 1200;      // èœ‚é¸£å™¨è½®è¯¢æ—¶é—´
  24          uint EEPROM_poll_neg_t = 0;      // EEPROMè´Ÿå€¼æ—¶é—´
  25          uint EEPROM_poll_time = 3000;    // EEPROMè½®è¯¢æ—¶é—´
  26          uint Weight_difference = 0;      // é‡é‡å·®
  27          
  28          uchar Key1_cnt = 0;  // æŒ‰é”®æ¶ˆæŠ–è®¡æ•°å€¼
  29          uchar Key2_cnt = 0;  // æŒ‰é”®æ¶ˆæŠ–è®¡æ•°å€¼
  30          uchar Key3_cnt = 0;  // æŒ‰é”®æ¶ˆæŠ–è®¡æ•°å€¼
  31          uchar Key4_cnt = 0;  // æŒ‰é”®æ¶ˆæŠ–è®¡æ•°å€¼
  32          BOOL Key1_event = 0; // æŒ‰é”®äº‹ä»¶
  33          BOOL Key2_event = 0; // æŒ‰é”®äº‹ä»¶
  34          BOOL Key3_event = 0; // æŒ‰é”®äº‹ä»¶
  35          BOOL Key4_event = 0; // æŒ‰é”®äº‹ä»¶
  36          
  37          char USB_Str[64];
  38          uint Item_Count = 0; // è®¡æ•°
  39          int Page = 1;        // é¡µé¢
  40          
  41          /**
  42           * @brief åˆå§‹åŒ–I/Oç«¯å£ï¼Œå°†æ¨¡å¼å¯„å­˜å™¨è®¾ç½®ä¸º0ã€‚
  43           *
  44           * æ­¤å‡½æ•°å°†æ‰€æœ‰æ¨¡å¼å¯„å­˜å™¨ï¼ˆP0M0, P0M1, P1M0, P1M1, P2M0, P2M1,
  45           * P4M0, P4M1, P5M0, P5M1, P6M0, P6M1, P7M0, P7M1ï¼‰è®¾ç½®ä¸º0ï¼Œ
  46           * å°†æ‰€æœ‰å¼•è„šé…ç½®ä¸ºé€šç”¨I/Oï¼Œæ— ç‰¹æ®ŠåŠŸèƒ½ã€‚
  47           */
  48          void IO_Init()
  49          {
  50   1          P0M0 = 0x00;
  51   1          P0M1 = 0x00;
  52   1          P1M0 = 0x00;
  53   1          P1M1 = 0x00;
  54   1          P2M0 = 0x00;
C51 COMPILER V9.59.0.0   APP_MAIN                                                          12/25/2024 14:50:49 PAGE 2   

  55   1          P2M1 = 0x00;
  56   1          P3M0 = 0x00;
  57   1          P3M1 = 0x00;
  58   1          P4M0 = 0x00;
  59   1          P4M1 = 0x00;
  60   1          P5M0 = 0x00;
  61   1          P5M1 = 0x00;
  62   1          P6M0 = 0x00;
  63   1          P6M1 = 0x00;
  64   1          P7M0 = 0x00;
  65   1          P7M1 = 0x00;
  66   1      }
  67          
  68          /**
  69           * @brief ä»»åŠ¡ä¸€
  70           * æ˜¾ç¤ºä¸ªäººä¿¡æ¯åœ¨LCD1602å±å¹•ä¸Š
  71           *
  72           * è¯¥å‡½æ•°LCD1602å±å¹•ä¸Šæ˜¾ç¤ºä¸ªäººä¿¡æ¯ã€‚
  73           * é¦–å…ˆæ˜¾ç¤ºå­¦å·â€œ20235603023185â€ï¼Œç„¶åå»¶è¿Ÿ500æ¯«ç§’ã€‚
  74           * æ¥ç€æ˜¾ç¤ºå§“åâ€œLinZhiKaiâ€ï¼Œå†å»¶è¿Ÿ2000æ¯«ç§’ã€‚
  75           * æœ€åæ¸…é™¤å±å¹•æ˜¾ç¤ºã€‚
  76           */
  77          void Display_PersonInfo()
  78          {
  79   1          sprintf(LCDstr, "%s", "20235603023185");
  80   1          LCD1602_Display_String(1, 2, LCDstr);
  81   1          DelayTick(500);
  82   1          sprintf(LCDstr, "%s", "LinZhiKai");
  83   1          LCD1602_Display_String(2, 4, LCDstr);
  84   1          DelayTick(2000);
  85   1          LCD1602_Wr_Command(0x01);
  86   1      }
  87          /**
  88           * @brief ä»»åŠ¡ä¸‰
  89           * æ˜¾ç¤ºé‡é‡ä¿¡æ¯åœ¨LCD1602å±å¹•ä¸Š
  90           *
  91           * è¯¥å‡½æ•°LCD1602å±å¹•ä¸Šæ˜¾ç¤ºé‡é‡ä¿¡æ¯ã€‚
  92           * é¦–å…ˆæ˜¾ç¤ºæ ‡å¿—å’Œå•ä½â€œWeight :â€ï¼Œâ€œgâ€ã€‚
  93           * æ¥ç€æ˜¾ç¤ºé‡é‡å€¼â€œweightâ€ï¼Œå»¶è¿Ÿ500æ¯«ç§’ã€‚
  94           * å¦‚æœé‡é‡å€¼ä¸º0ï¼Œåˆ™æ¸…é™¤é‡é‡å€¼ã€‚
  95           */
  96          void LCD_Display_Weight()
  97          {
  98   1      
  99   1          LCD1602_Display_String(1, 1, "Pi :");     // æ˜¾ç¤ºæ ‡å¿—
 100   1          LCD1602_Display_String(1, 10, "g");       // æ˜¾ç¤ºå•ä½
 101   1          LCD1602_Display_String(2, 1, "Weight :"); // æ˜¾ç¤ºæ ‡å¿—
 102   1          LCD1602_Display_String(2, 15, "g");       // æ˜¾ç¤ºå•ä½
 103   1      
 104   1          sprintf(LCDstr, "%4d", weight_tare);  // æ ¼å¼åŒ–å­—ç¬¦ä¸²
 105   1          LCD1602_Display_String(1, 5, LCDstr); // LCDæ˜¾ç¤ºå»çš®é‡é‡å€¼
 106   1          if (weigh_poll_neg_t + weigh_poll_time < Get_Tikc())
 107   1          {
 108   2              weight_tare_after = read_weight(weight_k, weight_base) - weight_tare; // è¯»å–é‡é‡
 109   2              printf("weight_base = %lu\n", weight_base);                           // Logæ‰“å°åŸºå‡†é‡é‡
 110   2              printf("weight = %d\n", weight_tare_after);                           // Logæ‰“å°é‡é‡
 111   2              printf("weight_k = %3d\n", weight_k);                                 // Logæ‰“å°é‡é‡ç³»æ•°
 112   2              weigh_poll_neg_t = Get_Tikc();
 113   2          }
 114   1      
 115   1          sprintf(LCDstr, "%4d", weight_tare_after); // æ ¼å¼åŒ–å­—ç¬¦ä¸²
 116   1          LCD1602_Display_String(2, 10, LCDstr);     // LCDæ˜¾ç¤ºé‡é‡å€¼
C51 COMPILER V9.59.0.0   APP_MAIN                                                          12/25/2024 14:50:49 PAGE 3   

 117   1          if (weight_tare_after <= 0)
 118   1          {
 119   2              LCD1602_Display_String(2, 10, "   0"); // æ¸…é™¤é‡é‡å€¼
 120   2          }
 121   1      }
 122          /**
 123           * @brief ä»»åŠ¡ä¸‰
 124           * å»çš®
 125           * è¯¥å‡½æ•°å»çš®ã€‚
 126           */
 127          void tare_weight()
 128          {
 129   1      
 130   1          if (Key3_event == 1 && Page == 1)
 131   1          {
 132   2              weight_tare = read_weight(weight_k, weight_base); // è¯»å–é‡é‡
 133   2              printf("weight_tare = %d\n", weight_tare);        // Logæ‰“å°å»çš®é‡é‡
 134   2              printf("weight_k = %3d\n", weight_k);             // Logæ‰“å°é‡é‡ç³»æ•°
 135   2          }
 136   1      }
 137          
 138          /**
 139           * @brief ä»»åŠ¡å››
 140           * è®¡æ•°
 141           * è¯¥å‡½æ•°è®¡æ•°ã€‚
 142           */
 143          void Count_weight()
 144          {
 145   1          if (read_weight(weight_k, weight_base) > 1000)
 146   1          {
 147   2              weight_count = 999;
 148   2          }
 149   1          else
 150   1          {
 151   2              weight_count = read_weight(weight_k, weight_base);
 152   2          }
 153   1      }
 154          
 155          /**
 156           * @brief ä»»åŠ¡å››
 157           * æ˜¾ç¤ºè®¡æ•°ä¿¡æ¯åœ¨LCD1602å±å¹•ä¸Š
 158           *
 159           * è¯¥å‡½æ•°LCD1602å±å¹•ä¸Šæ˜¾ç¤ºè®¡æ•°ä¿¡æ¯ã€‚
 160           * é¦–å…ˆæ˜¾ç¤ºæ ‡å¿—â€œCount :â€ã€‚
 161           * æ¥ç€æ˜¾ç¤ºè®¡æ•°å€¼â€œItem_Countâ€ã€‚
 162           * å¦‚æœè®¡æ•°å€¼å¤§äº100ï¼Œåˆ™è®¡æ•°å€¼ä¸º100ã€‚
 163           * æœ€åæ˜¾ç¤ºå•ä½â€œgâ€ã€‚
 164           */
 165          void LCD_Display_Count()
 166          {
 167   1      
 168   1          LCD1602_Display_String(2, 1, "Weight :"); // æ˜¾ç¤ºæ ‡å¿—
 169   1          LCD1602_Display_String(2, 15, "g");       // æ˜¾ç¤ºå•ä½
 170   1          LCD1602_Display_String(1, 1, "Count :");  // æ˜¾ç¤ºæ ‡å¿—
 171   1          LCD1602_Display_String(1, 12, "x");       // æ˜¾ç¤ºæ ‡å¿—
 172   1          LCD1602_Display_String(1, 16, "g");       // æ˜¾ç¤ºå•ä½
 173   1      
 174   1          if (weigh_poll_neg_t + weigh_poll_time < Get_Tikc())
 175   1          {
 176   2              weight = read_weight(weight_k, weight_base); // è¯»å–é‡é‡
 177   2              printf("weight = %d\n", weight);             // Logæ‰“å°é‡é‡å€¼
 178   2              printf("weight_count = %d\n", weight_count); // Logæ‰“å°è®¡æ•°é‡é‡å€¼
C51 COMPILER V9.59.0.0   APP_MAIN                                                          12/25/2024 14:50:49 PAGE 4   

 179   2              printf("Item_Count = %d\n", Item_Count);     // Logæ‰“å°è®¡æ•°å€¼
 180   2              printf("weight_k = %3d\n", weight_k);        // Logæ‰“å°é‡é‡ç³»æ•°
 181   2              weigh_poll_neg_t = Get_Tikc();
 182   2          }
 183   1          sprintf(LCDstr, "%4d", weight);        // æ ¼å¼åŒ–å­—ç¬¦ä¸²
 184   1          LCD1602_Display_String(2, 10, LCDstr); // LCDæ˜¾ç¤ºé‡é‡å€¼
 185   1          if (weight <= 0)
 186   1          {
 187   2              LCD1602_Display_String(2, 10, "   0"); // æ¸…é™¤é‡é‡å€¼
 188   2          }
 189   1      
 190   1          if (weight_count == 0)
 191   1          {
 192   2              LCD1602_Display_String(1, 13, "  0"); // æ¸…é™¤é‡é‡å€¼
 193   2              Item_Count = 0;
 194   2          }
 195   1          else
 196   1          {
 197   2              Item_Count = weight / weight_count; // è®¡æ•°
 198   2          }
 199   1          sprintf(LCDstr, "%3d", weight_count);  // æ ¼å¼åŒ–å­—ç¬¦ä¸²
 200   1          LCD1602_Display_String(1, 13, LCDstr); // æ˜¾ç¤ºä¸ªé‡é‡å€¼
 201   1      
 202   1          if (Item_Count >= 100)
 203   1          {
 204   2              Item_Count = 100;
 205   2          }
 206   1          sprintf(LCDstr, "%3d", Item_Count);   // æ ¼å¼åŒ–å­—ç¬¦ä¸²
 207   1          LCD1602_Display_String(1, 8, LCDstr); // LCDæ˜¾ç¤ºè®¡æ•°å€¼
 208   1          if (Item_Count == 0)
 209   1          {
 210   2              LCD1602_Display_String(1, 8, "  0"); // æ¸…é™¤è®¡æ•°å€¼
 211   2          }
 212   1      }
 213          
 214          /**
 215           * @brief ä»»åŠ¡äº”
 216           * è¶…é‡æŠ¥è­¦
 217           * è¯¥å‡½æ•°è¶…é‡æŠ¥è­¦ã€‚
 218           */
 219          void Overweight_alarm()
 220          {
 221   1          LCD1602_Display_String(2, 1, "Weight :"); // æ˜¾ç¤ºæ ‡å¿—
 222   1          weight = read_weight(weight_k, weight_base);
 223   1          sprintf(LCDstr, "%4d", weight);              // æ ¼å¼åŒ–å­—ç¬¦ä¸²
 224   1          LCD1602_Display_String(2, 10, LCDstr);       // LCDæ˜¾ç¤ºé‡é‡å€¼
 225   1          LCD1602_Display_String(2, 15, "g");          // æ˜¾ç¤ºå•ä½
 226   1          LCD1602_Display_String(1, 1, "threshold :"); // æ˜¾ç¤ºæ ‡å¿—
 227   1          sprintf(LCDstr, "%3d", threshold);           // æ ¼å¼åŒ–å­—ç¬¦ä¸²
 228   1          LCD1602_Display_String(1, 12, LCDstr);       // æ˜¾ç¤ºæ ‡å¿—
 229   1          LCD1602_Display_String(1, 16, "g");          // æ˜¾ç¤ºå•ä½
 230   1          Weight_difference = weight / threshold;      // è®¡ç®—é‡é‡å·®
 231   1          if (threshold == 0)
 232   1          {
 233   2              Weight_difference = 0;
 234   2          }
 235   1      
 236   1          if (weight > threshold && weight != 0)
 237   1          {
 238   2              if (beep_neg_time + beep_poll_time - (weight / (threshold + 50) * 100) < Get_Tikc())
 239   2              {
 240   3                  BEEP = ~BEEP;
C51 COMPILER V9.59.0.0   APP_MAIN                                                          12/25/2024 14:50:49 PAGE 5   

 241   3                  LED3 = ~LED3;
 242   3                  LED1 = 0;
 243   3                  printf("weight = %4d\n", weight);     // Logæ‰“å°é‡é‡å€¼
 244   3                  printf("threshold = %3d", threshold); // Logæ‰“å°é˜ˆå€¼
 245   3                  printf("weight_k = %3d\n", weight_k); // Logæ‰“å°é‡é‡ç³»æ•°
 246   3                  beep_neg_time = Get_Tikc();
 247   3              }
 248   2          }
 249   1          else
 250   1          {
 251   2              BEEP = 1;
 252   2              LED3 = 1;
 253   2          }
 254   1      }
 255          
 256          /**
 257           * @brief ä»»åŠ¡äº”
 258           * é‡é‡é˜ˆå€¼
 259           * è¯¥å‡½æ•°é‡é‡é˜ˆå€¼ã€‚
 260           */
 261          void Weight_threshold(uint k)
 262          {
 263   1      
 264   1          if (k == 1)
 265   1          {
 266   2              threshold++;
 267   2          }
 268   1          else if (k == 2 && threshold > 0)
 269   1          {
 270   2              threshold--;
 271   2          }
 272   1          else if (k == 3)
 273   1          {
 274   2              /* code */
 275   2          }
 276   1          else if (k == 4)
 277   1          {
 278   2              threshold = read_weight(weight_k, weight_base);
 279   2          }
 280   1      }
 281          
 282          /**
 283           * @brief ä»»åŠ¡å…­
 284           * é¡µé¢åˆ‡æ¢
 285           * è¯¥å‡½æ•°é¡µé¢åˆ‡æ¢ã€‚
 286           */
 287          void Page_Switching()
 288          {
 289   1          BEEP = 1;
 290   1          LED3 = 1;
 291   1          LCD1602_Wr_Command(0x01);
 292   1          Page++;
 293   1          if (Page > 4)
 294   1          {
 295   2              Page = 1;
 296   2          }
 297   1      }
 298          
 299          void usb_set_weight_K(BYTE UsbOut[], BYTE *size_t)
 300          {
 301   1          uint i;
 302   1          for (i = 0; i < *size_t; i++)
C51 COMPILER V9.59.0.0   APP_MAIN                                                          12/25/2024 14:50:49 PAGE 6   

 303   1          {
 304   2              usbStr[i] = UsbOut[i];
 305   2          }
 306   1          if (usbStr[0] == '#')
 307   1          {
 308   2              usb_weight_k = (usbStr[1] - '0') * 100 + (usbStr[2] - '0') * 10 + (usbStr[3] - '0'); // è®¾ç½®é‡é
             -‡ç³»æ•°
 309   2              AT24C04_WritePage(AT24C04_ADDRESS, 0x00, UsbOut);                                    // å†™å…¥EEPR
             -OMé‡é‡ç³»æ•°
 310   2          }
 311   1          weight_k = usb_weight_k;
 312   1          sprintf(USB_Str, "k = %3d\n", weight_k);
 313   1          USB_SendData(USB_Str, 9); // Logæ‰“å°é‡é‡ç³»æ•°
 314   1      }
 315          
 316          /**
 317           * @brief EEPROMè½®è¯¢è¯»å–
 318           * è¯¥å‡½æ•°EEPROMè½®è¯¢è¯»å–ã€‚
 319           */
 320          void EEPROM_Poll_Read()
 321          {
 322   1          if (EEPROM_poll_neg_t + EEPROM_poll_time < Get_Tikc())
 323   1          {
 324   2              AT24C04_ReadPage(AT24C04_ADDRESS, 0x00, EEPROM_weight_k, 4);                                      
             -           // è¯»å–EEPROMé‡é‡ç³»æ•°
 325   2              weight_k2 = (EEPROM_weight_k[1] - '0') * 100 + (EEPROM_weight_k[2] - '0') * 10 + (EEPROM_weight_k[
             -3] - '0'); // è®¾ç½®é‡é‡ç³»æ•°
 326   2              printf("Ek = %d\n", weight_k2);                                                                   
             -           // Logæ‰“å°é‡é‡ç³»æ•°
 327   2              EEPROM_poll_neg_t = Get_Tikc();                                                                   
             -           // é‡ç½®EEPROMè´Ÿå€¼æ—¶é—´
 328   2          }
 329   1      }
 330          
 331          void app_main()
 332          {
 333   1      
 334   1          // æ‰©å±•å¯„å­˜å™¨(XFR)è®¿é—®ä½¿èƒ½
 335   1          P_SW2 |= 0x80;
 336   1          IO_Init();                                                  // åˆå§‹åŒ–I/Oç«¯å£
 337   1          usb_init();                                                 // USBåˆå§‹åŒ–
 338   1          Timer0_Init();                                              // å®šæ—¶å™¨0åˆå§‹åŒ–
 339   1          EA = 1;                                                     // å¼€å¯æ€»ä¸­æ–­
 340   1          while (DeviceState != DEVSTATE_CONFIGURED && chishu > 1000) // ç­‰å¾…USBé…ç½®å®Œæˆ
 341   1          {
 342   2              DelayTick(1);
 343   2          }
 344   1          LCD1602_Init();       // åˆå§‹åŒ–LCD1602
 345   1          I2C_Init();           // åˆå§‹åŒ–I2C
 346   1          Display_PersonInfo(); // æ˜¾ç¤ºä¸ªäººä¿¡æ¯
 347   1          AT24C04_ReadPage(AT24C04_ADDRESS, 0x00, EEPROM_weight_k, 4);
 348   1          weight_k2 = (EEPROM_weight_k[1] - '0') * 100 + (EEPROM_weight_k[2] - '0') * 10 + (EEPROM_weight_k[3] -
             - '0');
 349   1          printf("Ek = %d\n", weight_k2);
 350   1          weight_k = weight_k2;
 351   1          weight_base = read_weight_base(); // è¯»å–åŸºå‡†é‡é‡
 352   1          while (1)
 353   1          {
 354   2      
 355   2              if (P54 == 0)
 356   2              {
 357   3              }
C51 COMPILER V9.59.0.0   APP_MAIN                                                          12/25/2024 14:50:49 PAGE 7   

 358   2      
 359   2              Key1_event = keyScan(&Key1_cnt, !Key1); // æŒ‰é”®æ‰«æ
 360   2              Key2_event = keyScan(&Key2_cnt, !Key2); // æŒ‰é”®æ‰«æ
 361   2              Key3_event = keyScan(&Key3_cnt, !Key3); // æŒ‰é”®æ‰«æ
 362   2              Key4_event = keyScan(&Key4_cnt, !Key4); // æŒ‰é”®æ‰«æ
 363   2              if (Key1_event == 1)
 364   2              {
 365   3                  if (Page == 1)
 366   3                  {
 367   4                      /* code */
 368   4                  }
 369   3                  if (Page == 2)
 370   3                  {
 371   4                      Count_weight();
 372   4                  }
 373   3                  if (Page == 3)
 374   3                  {
 375   4                  }
 376   3              }
 377   2              if (Key2_event == 1)
 378   2              {
 379   3                  if (Page == 1)
 380   3                  {
 381   4                      /* code */
 382   4                  }
 383   3                  if (Page == 2)
 384   3                  {
 385   4                      /* code */
 386   4                  }
 387   3                  if (Page == 3)
 388   3                  {
 389   4                  }
 390   3              }
 391   2              if (Key3_event == 1)
 392   2              {
 393   3      
 394   3                  if (Page == 1)
 395   3                  {
 396   4                      tare_weight();
 397   4                  }
 398   3                  if (Page == 2)
 399   3                  {
 400   4                      /* code */
 401   4                  }
 402   3                  if (Page == 3)
 403   3                  {
 404   4                      Weight_threshold(3);
 405   4                  }
 406   3                  if (Page == 4)
 407   3                  {
 408   4                      AT24C04_ReadPage(AT24C04_ADDRESS, 0x00, EEPROM_weight_k, 4);                              
             -                   // è¯»å–EEPROMé‡é‡ç³»æ•°
 409   4                      printf("Ek = %s\n", EEPROM_weight_k);                                                     
             -                   // Logæ‰“å°é‡é‡ç³»æ•°
 410   4                      weight_k2 = (EEPROM_weight_k[1] - '0') * 100 + (EEPROM_weight_k[2] - '0') * 10 + (EEPROM_w
             -eight_k[3] - '0'); // æ ¼å¼åŒ–é‡é‡ç³»æ•°
 411   4                      printf("k = %d\n", weight_k2);                                                            
             -                   // Logæ‰“å°é‡é‡ç³»æ•°
 412   4                  }
 413   3              }
 414   2              if (Key4_event == 1)
 415   2              {
C51 COMPILER V9.59.0.0   APP_MAIN                                                          12/25/2024 14:50:49 PAGE 8   

 416   3      
 417   3                  Page_Switching();
 418   3              }
 419   2      
 420   2              if (poll_neg_t + poll_time < Get_Tikc())
 421   2              {
 422   3      
 423   3                  // printf("Page = %d\n", Page); // Logæ‰“å°é¡µé¢
 424   3                  switch (Page)
 425   3                  {
 426   4                  case 1:
 427   4      
 428   4                      LCD_Display_Weight(); // æ˜¾ç¤ºé‡é‡
 429   4      
 430   4                      break;
 431   4                  case 2:
 432   4                      LCD_Display_Count(); // æ˜¾ç¤ºè®¡æ•°
 433   4                      break;
 434   4                  case 3:
 435   4                      if (Key1 == 0 && Key2 == 1 && Page == 3)
 436   4                      {
 437   5                          Weight_threshold(1);
 438   5                      }
 439   4                      if (Key2 == 0 && Key1 == 1 && Page == 3)
 440   4                      {
 441   5                          Weight_threshold(2);
 442   5                      }
 443   4                      if (Key1 == 0 && Key2 == 0 && Page == 3)
 444   4                      {
 445   5                          Weight_threshold(4);
 446   5                      }
 447   4                      Overweight_alarm();
 448   4                      break;
 449   4                  case 4:
 450   4                      sprintf(LCDstr, "k = %d", weight_k);
 451   4                      LCD1602_Display_String(1, 1, LCDstr);
 452   4      
 453   4                      sprintf(LCDstr, "Ek = %d", weight_k2);
 454   4                      LCD1602_Display_String(2, 1, LCDstr);
 455   4                      break;
 456   4                  default:
 457   4                      LCD1602_Wr_Command(0x01);
 458   4                      break;
 459   4                  }
 460   3                  LED1 = ~LED1;
 461   3                  // LED2 = ~LED2;
 462   3                  // LED3 = ~LED3;
 463   3                  poll_neg_t = Get_Tikc();
 464   3              }
 465   2          }
 466   1      }
 467          
 468          BOOL usb_OUT_callback()
 469          {
 470   1          // æ¥æ”¶å­—èŠ‚æ•°ä¿å­˜åœ¨OutNumberä¸­
 471   1          // æ¥æ”¶æ•°æ®ä¿å­˜åœ¨UsbOutBufferç¼“å†²åŒº
 472   1          // USB_SendData("ok", 2);
 473   1      
 474   1          usb_set_weight_K(UsbOutBuffer, &OutNumber); // è®¾ç½®é‡é‡ç³»æ•°
 475   1          return 1;
 476   1      }

C51 COMPILER V9.59.0.0   APP_MAIN                                                          12/25/2024 14:50:49 PAGE 9   


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3113    ----
   CONSTANT SIZE    =    274    ----
   XDATA SIZE       =    218       6
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
